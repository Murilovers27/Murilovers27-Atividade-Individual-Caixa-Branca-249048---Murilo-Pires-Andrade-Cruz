# Atividade-Individual-Caixa-Branca-249048 - Murilo Pires Andrade Cruz

Neste reposit√≥rio, apresento minha an√°lise est√°tica e estrutural de uma classe Java (`User.java`), aplicando os conceitos de teste de caixa branca para identificar vulnerabilidades e definir uma estrat√©gia de teste de ciclo.

---

## 1.  Etapa 1: Inspe√ß√£o de C√≥digo (An√°lise Est√°tica)

Iniciei o processo com uma revis√£o manual (inspe√ß√£o est√°tica) do arquivo `User.java`. O objetivo era identificar "code smells", vulnerabilidades e m√°s pr√°ticas de design antes mesmo de executar o c√≥digo.

A inspe√ß√£o revelou rapidamente problemas estruturais graves:

* **Viola√ß√£o de Arquitetura:** A classe `User` (uma entidade) estava gerenciando conex√µes de BD, o que quebra o princ√≠pio da Separa√ß√£o de Camadas.
* **Vazamento de Recursos:** Nenhum dos objetos (`Connection`, `Statement`, `ResultSet`) estava sendo fechado com `.close()`, o que levaria ao esgotamento do pool de conex√µes.
* **Risco Cr√≠tico de NPE:** O m√©todo `conectarBD` retorna `null` em caso de falha, mas o m√©todo `verificarUsuario` n√£o valida isso antes de usar a conex√£o.

### Planilha de Inspe√ß√£o

Os 7 pontos de falha detalhados est√£o documentados na tabela abaixo:

| ID | ITEM | STATUS | ARTEFATO COM ERRO | AN√ÅLISE DO PROBLEMA |
| :--- | :--- | :--- | :--- | :--- |
| 1 | O c√≥digo foi devidamente documentado? | **N√ÉO** | M√©todos `conectarBD` e `verificarUsuario` | Faltam os coment√°rios Javadoc para explicar o que cada m√©todo faz, seus par√¢metros e seus retornos. |
| 2 | As vari√°veis e constantes possuem nomenclatura? | **N√ÉO** | Vari√°veis `st`, `rs`, `nome`, `result` | Nomes como `st` e `rs` s√£o muito curtos. `nome` e `result` foram criadas no escopo global, mas s√≥ s√£o usadas localmente. |
| 3 | Existem legibilidade e organiza√ß√£o no c√≥digo? | **N√ÉO** | Classe `User` | A organiza√ß√£o est√° fraca. A classe `User` (que deveria guardar dados) est√° a misturar responsabilidades e a tentar gerir a conex√£o ao BD. |
| 4.1 | Todos os NullPointers foram tratados? | **N√ÉO** | M√©todo `conectarBD` (Origem do Risco) | O m√©todo `conectarBD()` pode devolver `null` (se falhar), mas "engole" o erro no `catch` vazio, passando o risco para frente. |
| 4.2 | Todos os NullPointers foram tratados? | **N√ÉO** | M√©todo `verificarUsuario` (Uso do Risco) | O c√≥digo n√£o verifica `if (conn != null)` antes de tentar usar a vari√°vel `conn` (que veio `null` do item 4.1). |
| 5.1 | As conex√µes utilizadas foram fechadas? | **N√ÉO** | M√©todo `verificarUsuario` (Vazamento 1) | O objeto `Connection` (`conn`) √© aberto, mas nunca √© fechado com `.close()`. |
| 5.2 | As conex√µes utilizadas foram fechadas? | **N√ÉO** | M√©todo `verificarUsuario` (Vazamento 2) | Os objetos `Statement` (`st`) e `ResultSet` (`rs`) tamb√©m s√£o abertos e nunca fechados. |

*(O arquivo-fonte desta planilha pode ser encontrado em: `public/MYP.jpg` e `ExercicioCaixaBranca(1).x`)*

---

## 2.  Etapa 2: An√°lise Estrutural e Ciclom√°tica

Ap√≥s a inspe√ß√£o, mapeei o fluxo l√≥gico do m√©todo `verificarUsuario()` para entender sua complexidade e definir quantos testes seriam necess√°rios para uma cobertura completa.

### 2.1. Grafo de Fluxo de Controle (6 N√≥s)

O grafo abaixo (exportado da pasta `public/`) simplifica o m√©todo em 6 n√≥s de decis√£o/a√ß√£o.

![Grafo de Fluxo de Controle - 6 N√≥s](public/grafoDeFluxo.jpg)

### 2.2. Complexidade Ciclom√°tica (V(G))

Para calcular o n√∫mero m√≠nimo de testes necess√°rios, usei a f√≥rmula de complexidade ciclom√°tica:

$$V(G) = E - N + 2$$

Onde (para o grafo simplificado de 6 n√≥s):
* **N (N√≥s):** 6
* **E (Arestas):** 7

**C√°lculo:**
$$V(G) = 7 - 6 + 2 = 3$$

O resultado **V(G)=3** confirma que precisamos de **3 testes** para cobrir 100% dos caminhos l√≥gicos do m√©todo.

### 2.3. Caminhos de Teste Identificados

Os 3 caminhos de teste independentes s√£o:

1.  **Caminho de Sucesso:** O `try` funciona e o `if(rs.next())` √© verdadeiro (usu√°rio encontrado).
2.  **Caminho Normal:** O `try` funciona, mas o `if(rs.next())` √© falso (usu√°rio n√£o encontrado).
3.  **Caminho de Exce√ß√£o:** O `try` falha e o bloco `catch` √© executado (ex: falha de conex√£o).

---
## 3.  Etapa 3: Valida√ß√£o Pr√°tica e Diagn√≥stico

A parte final foi validar a an√°lise te√≥rica. Adicionei um m√©todo `main` ao `User.java` original para for√ßar a execu√ß√£o dos 3 caminhos de teste.

### 3.1. Diagn√≥stico da Falha

O resultado foi conclusivo: **todos os 3 caminhos retornaram 'false'**. At√© mesmo o "Caminho Feliz" (Teste 1) falhou.

Isso provou que a execu√ß√£o **nunca** chegava ao `if(rs.next())`, e que o **Caminho 3 (Exce√ß√£o)** estava sempre sendo executado, mesmo quando o banco de dados estava "ligado".

Este teste validou perfeitamente as descobertas da Etapa 1 (An√°lise Est√°tica):

> 1.  O `conectarBD()` falha ao tentar conectar (ex: senha `123456` errada).
> 2.  Por ter um `catch` vazio, ele "engole" o erro e retorna `null`.
> 3.  O `verificarUsuario()` recebe esse `null` na vari√°vel `conn`.
> 4.  A linha `conn.createStatement()` tenta usar o `null`, gerando um **`NullPointerException`**.
> 5.  Esse `NPE` √© capturado pelo segundo `catch` (tamb√©m vazio), e o m√©todo simplesmente termina, retornando seu valor padr√£o (`false`).

**Conclus√£o:** A an√°lise pr√°tica confirmou que os blocos `catch` vazios e a falta de tratamento de `null` (identificados na inspe√ß√£o est√°tica) eram a causa raiz da falha total do m√©todo.

---

## 4. üõ†Ô∏è C√≥digos-Fonte

* **[Vers√£o Original](vers√£oOriginal/User.java)**: O c√≥digo-fonte defeituoso que foi alvo desta an√°lise e teste.
* **[Vers√£o Corrigida](Vers√£oCorrigida/User.java)**: O c√≥digo que refatorei, usando `try-with-resources` e `PreparedStatement`.# Murilovers27-Atividade-Individual-Caixa-Branca-249048---Murilo-Pires-Andrade-Cruz
